mainmodule main{
	readonly CProxy_Cell cellProxy;
  readonly CProxy_Intflux interfaceProxy;
	readonly int global_t_steps

	message Msg{
		//int dir_cp;
		flow val[];
	};

	mainchare Main{
    entry Main(CkArgMsg* msg);
    entry [reductiontarget] void done();
  };

	array[3D] Cell{
		entry void calc_val(flow3D);
		entry void run(){
			for (iter = 0; iter < t_steps; iter++){
				serial{
					Msg *m; // ppp: variable-size messages need size
					//m->dir_cp = 0;
					//memcpy(m->val,fval_old,numdiv*numdiv*numdiv*sizeof(flow));
					for (int i = 0; i < numdiv; i++){
						for (int j = 0; j < numdiv; j++){
							for (int k = 0; k < numdiv; k++){
						 		m->val[numdiv*numdiv*i+numdiv*j+k] = fval_old[i][j][k];
						 }
						}
					}
					fluxProxy(thisIndex.x,thisIndex.y,thisIndex.z).calc_flux(iter*4,m);
				}
				when calc_val[iter*4](int tag, Msg *m) serial{
					for (int i = 0; i < numdiv; i++){
						for (int j = 0; j < numdiv; j++){
							for (int k = 0; k < numdiv; k++){
								k1[i][j][k] = m->val[numdiv*numdiv*i+numdiv*j+k];
					 		}
						}
					}
					calcvar3D(var1,fval_old,k1);
					vecdiv3D(temp2,var1,double(2),numdiv);
					vecadd3D(temp,fval_old,temp2,numdiv);
					gaslaw(temp);
					for (int i = 0; i < numdiv; i++){
						for (int j = 0; j < numdiv; j++){
							for (int k = 0; k < numdiv; k++){
						 		m->val[numdiv*numdiv*i+numdiv*j+k] = var1[i][j][k];
						 }
						}
					}
					fluxProxy(thisIndex.x,thisIndex.y,thisIndex.z).calc_flux(iter*4+1,m);
				}
				when calc_val[iter*4+1](int tag, Msg *m) serial{
					for (int i = 0; i < numdiv; i++){
						for (int j = 0; j < numdiv; j++){
							for (int k = 0; k < numdiv; k++){
								k2[i][j][k] = m->val[numdiv*numdiv*i+numdiv*j+k];
					 		}
						}
					}
					calcvar3D(var2,var1,k2);
					vecdiv3D(temp2,var2,double(2),numdiv);
					vecadd3D(temp,fval_old,temp2,numdiv);
					gaslaw(temp);
					for (int i = 0; i < numdiv; i++){
						for (int j = 0; j < numdiv; j++){
							for (int k = 0; k < numdiv; k++){
						 		m->val[numdiv*numdiv*i+numdiv*j+k] = var2[i][j][k];
						 }
						}
					}
					fluxProxy(thisIndex.x,thisIndex.y,thisIndex.z).calc_flux(iter*4+2,m);
				}
				when calc_val[iter*4+2](int tag, Msg *m) serial{
					for (int i = 0; i < numdiv; i++){
						for (int j = 0; j < numdiv; j++){
							for (int k = 0; k < numdiv; k++){
								k3[i][j][k] = m->val[numdiv*numdiv*i+numdiv*j+k];
							}
						}
					}
					calcvar3D(var3,var2,k3);
					vecadd3D(temp,fval_old,var3,numdiv);
					gaslaw(temp);
					for (int i = 0; i < numdiv; i++){
						for (int j = 0; j < numdiv; j++){
							for (int k = 0; k < numdiv; k++){
						 		m->val[numdiv*numdiv*i+numdiv*j+k] = var3[i][j][k];
						 }
						}
					}
					fluxProxy(thisIndex.x,thisIndex.y,thisIndex.z).calc_flux(iter*4+3,m);
				}
				when calc_val[iter*4+3](int tag, Msg *m)) serial{
					for (int i = 0; i < numdiv; i++){
						for (int j = 0; j < numdiv; j++){
							for (int k = 0; k < numdiv; k++){
								k4[i][j][k] = m->val[numdiv*numdiv*i+numdiv*j+k];
							}
						}
					}
				}
				serial{
					vecselfmul3D(k2,double(2),numdiv);
					vecselfmul3D(k3,double(2),numdiv);
					vecselfadd3D(k1,k2,numdiv);
					vecselfadd3D(k3,k4,numdiv);
					vecselfadd3D(k1,k3,numdiv);
					vecselfdiv3D(k1,double(6),numdiv);
					calcvar3D(fval_new,fval_old,k1);
					gaslaw(fval_new);
					fval_new = fval_old;
					delete m;
				}
			}
			serial{
				CkCallback cb(CkReductionTarget(Main,done),mainProxy);
				contribute(cb);
			}
		};
	};

	array[3D] Flux{
		entry void calc_flux(flow3D);
		entry void run_flux(){
			for (iter = 0; iter < t_steps; iter++){
				for (it = 0; it < 4; it++){
					when calc_flux[iter*4+it](int tag_c, Msg *m) serial{
						for (int i = 0; i < numdiv; i++){
							for (int j = 0; j < numdiv; j++){
								for (int k = 0; k < numdiv; k++){
									cell_val[i][j][k] = m->val[numdiv*numdiv*i+numdiv*j+k];
								}
							}
						}
					}
					serial{
						interfaceProxy(0,thisIndex.x,thisIndex.y,thisIndex.z).interflux_comm(0,m11);
						interfaceProxy(0,thisIndex.x+1,thisIndex.y,thisIndex.z).interflux_comm(1,m12);
						interfaceProxy(1,thisIndex.y,thisIndex.z,thisIndex.x).interflux_comm(0,m13);
						interfaceProxy(1,thisIndex.y+1,thisIndex.z,thisIndex.x).interflux_comm(1,m14);
						interfaceProxy(2,thisIndex.z,thisIndex.x,thisIndex.y).interflux_comm(0,m15);
						interfaceProxy(2,thisIndex.z+1,thisIndex.x,thisIndex.y).interflux_comm(1,m16);
					}
					overlap{
						serial{
							inviscidFlux(flux_f,cell_val);
						}
						when flux_comm[0](int tag, Msg *m1){
							for (int i = 0; i < numdiv; i++){
								for (int j = 0; j < numdiv; j++){
									flux_f[0][0][i][j] = m1->val[numdiv*i+j];
								}
							}
						}
						when flux_comm[1](int tag, Msg *m1){
							for (int i = 0; i < numdiv; i++){
								for (int j = 0; j < numdiv; j++){
									flux_f[0][numdiv][i][j] = m1->val[numdiv*i+j];
								}
							}
						}
						when flux_comm[2](int tag, Msg *m1){
							for (int i = 0; i < numdiv; i++){
								for (int j = 0; j < numdiv; j++){
									flux_f[1][0][i][j] = m1->val[numdiv*i+j];
								}
							}
						}
						when flux_comm[3](int tag, Msg *m1){
							for (int i = 0; i < numdiv; i++){
								for (int j = 0; j < numdiv; j++){
									flux_f[1][numdiv][i][j] = m1->val[numdiv*i+j];
								}
							}
						}
						when flux_comm[4](int tag, Msg *m1){
							for (int i = 0; i < numdiv; i++){
								for (int j = 0; j < numdiv; j++){
									flux_f[2][0][i][j] = m1->val[numdiv*i+j];
								}
							}
						}
						when flux_comm[5](int tag, Msg *m1){
							for (int i = 0; i < numdiv; i++){
								for (int j = 0; j < numdiv; j++){
									flux_f[2][numdiv][i][j] = m1->val[numdiv*i+j];
								}
							}
						}
					} // end overlap
					serial{
						fluxFacetoCell(flux_c,flux_v);
					}
				} // end for (it = 0 thru 3)
				
				serial { // ppp: probably need to add serial
					for (int i = 0; i < numdiv; i++){
						for (int j = 0; j < numdiv; j++){
							for (int k = 0; k < numdiv; k++){
								m->val[numdiv*numdiv*i+numdiv*j+k] = flux_c[i][j[k]];
							}
						}
					}
					cellProxy(thisIndex.x,thisIndex.y,thisIndex.z).calc_val(tag_c,m);
				}
			} // end for(iterations)
		};
	};

	array[4D] intFlux{ // ppp: declaration of intFlux in .C ???
		entry void run_interface(){
			// ppp: probably we need to pack message here ------------------
			Msg* m = new (numdiv * numdiv * numdiv) Msg();
			for (int i = 0; i < numdiv; i++){
						for (int j = 0; j < numdiv; j++){
							for (int k = 0; k < numdiv; k++){
							// what to assign here?????
						 		m->val[numdiv*numdiv*i+numdiv*j+k] = fval_old[i][j][k]; 
						 }
						}
					}
			fluxProxy(thisIndex.x,thisIndex.y,thisIndex.z).calc_flux(iter*4,m);
			// end ppp --------------------


			if (thisIndex.x == 0){
				when interflux_comm[0](int tag, Msg *m){
					wall();
					// Add message packing -----------------> not here
					if (thisIndex.u == 0){
						fluxProxy(thisIndex.x,thisIndex.y,thisIndex.z).flux_comm(0,m);
					}
					else if (thisIndex.u == 1){
						fluxProxy(thisIndex.z,thisIndex.x,thisIndex.y).flux_comm(2,m);
					}
					else if (thisIndex.u == 2){
						fluxProxy(thisIndex.y,thisIndex.z,thisIndex.x).flux_comm(4,m);
					}
				}
			}
			else if (thisIndex.x == numdiv){
				when interflux_comm[1](int tag, Msg *m){
					wall();
					if (thisIndex.u == 0){
						fluxProxy(thisIndex.x-1,thisIndex.y,thisIndex.z).flux_comm(1,m);
					}
					else if (thisIndex.u == 1){
						fluxProxy(thisIndex.z,thisIndex.x-1,thisIndex.y).flux_comm(3,m);
					}
					else if (thisIndex.u == 2){
						fluxProxy(thisIndex.y,thisIndex.z,thisIndex.x-1).flux_comm(5,m);
					}
				}
			}
			else{
				overlap{
					when interflux_comm[0](int tag, Msg *m){
						//Message unpack
					}
					when interflux_comm[1](int tag, Msg *m){
						//Message unpack
					}
					inviscidFlux();
					//Message pack

					serial { // ppp: serial block added
						if (thisIndex.u == 0){
							fluxProxy(thisIndex.x,thisIndex.y,thisIndex.z).flux_comm(0,m);
							fluxProxy(thisIndex.x-1,thisIndex.y,thisIndex.z).flux_comm(1,m);
						}
						else if (thisIndex.u == 1){
							fluxProxy(thisIndex.z,thisIndex.x,thisIndex.y).flux_comm(2,m);
							fluxProxy(thisIndex.z,thisIndex.x-1,thisIndex.y).flux_comm(3,m);
						}
						else if (thisIndex.u == 2){
							fluxProxy(thisIndex.y,thisIndex.z,thisIndex.x).flux_comm(4,m);
							fluxProxy(thisIndex.y,thisIndex.z,thisIndex.x-1).flux_comm(5,m);
						}
					}
				}
			}
		};
	}; // ppp: semicolon added here
};
